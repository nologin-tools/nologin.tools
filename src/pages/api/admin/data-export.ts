import type { APIRoute } from 'astro';
import { getDb } from '../../../db';
import { tools, tags } from '../../../db/schema';
import { eq } from 'drizzle-orm';
import { api } from '../../../lib/api';

export const POST: APIRoute = async ({ request, locals }) => {
  const env = locals.runtime.env;
  const db = getDb(env.DB);

  let body: any;
  try {
    body = await request.json();
  } catch {
    return api.error('Invalid JSON body.', 400);
  }

  const { secret } = body;

  if (!env.ADMIN_SECRET || secret !== env.ADMIN_SECRET) {
    return api.error('Unauthorized.', 401);
  }

  if (!env.GITHUB_TOKEN) {
    return api.error('GITHUB_TOKEN not configured.', 500);
  }

  // Query approved tools
  const approvedTools = await db
    .select({
      id: tools.id,
      slug: tools.slug,
      name: tools.name,
      url: tools.url,
      description: tools.description,
      coreTask: tools.coreTask,
    })
    .from(tools)
    .where(eq(tools.status, 'approved'))
    .orderBy(tools.name);

  // Query tags for approved tools only
  const allTags = await db
    .select({
      toolId: tags.toolId,
      tagKey: tags.tagKey,
      tagValue: tags.tagValue,
    })
    .from(tags)
    .innerJoin(tools, eq(tools.id, tags.toolId))
    .where(eq(tools.status, 'approved'));

  const tagMap = new Map<number, { key: string; value: string }[]>();
  for (const tag of allTags) {
    if (!tagMap.has(tag.toolId)) tagMap.set(tag.toolId, []);
    tagMap.get(tag.toolId)!.push({ key: tag.tagKey, value: tag.tagValue });
  }

  const toolsList = approvedTools.map((t) => ({
    slug: t.slug,
    name: t.name,
    url: t.url,
    description: t.description,
    coreTask: t.coreTask,
    tags: tagMap.get(t.id) || [],
  }));

  // Generate files
  const toolsJson = JSON.stringify(toolsList, null, 2);
  const readme = generateReadme(toolsList);

  // Push to GitHub
  const repo = 'nologin-tools/awesome-nologin-tools';
  const token = env.GITHUB_TOKEN;

  const files: { path: string; updated: boolean }[] = [];

  try {
    const jsonResult = await pushToGithub(token, repo, 'tools.json', toolsJson);
    files.push({ path: 'tools.json', updated: jsonResult.updated });
  } catch (err: any) {
    return api.error(`Failed to push tools.json: ${err.message}`, 500);
  }

  try {
    const readmeResult = await pushToGithub(token, repo, 'README.md', readme);
    files.push({ path: 'README.md', updated: readmeResult.updated });
  } catch (err: any) {
    return api.error(`Failed to push README.md: ${err.message}`, 500);
  }

  return api.success({
    toolCount: toolsList.length,
    files,
  });
};

function generateReadme(
  tools: {
    name: string;
    url: string;
    description: string | null;
    coreTask: string;
    tags: { key: string; value: string }[];
  }[]
): string {
  let md = `# Awesome NoLogin Tools\n\n`;
  md += `> A curated list of tools that work without login. Auto-generated from [nologin.tools](https://nologin.tools).\n\n`;
  md += `## Tools\n\n`;

  for (const tool of tools) {
    const tagStr = tool.tags.map((t) => `\`${t.key}:${t.value}\``).join(' ');
    md += `- [${tool.name}](${tool.url}) — ${tool.description || tool.coreTask}`;
    if (tagStr) md += ` ${tagStr}`;
    md += `\n`;
  }

  md += `\n---\n\nGenerated by [nologin.tools](https://nologin.tools).\n`;
  return md;
}

async function pushToGithub(
  token: string,
  repo: string,
  path: string,
  content: string
): Promise<{ updated: boolean }> {
  const url = `https://api.github.com/repos/${repo}/contents/${path}`;
  const headers = {
    Authorization: `Bearer ${token}`,
    'User-Agent': 'NoLoginTools-Exporter/1.0',
  };

  // Get current file SHA and content (if exists)
  let sha: string | undefined;
  let existingContent: string | undefined;
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000);
    const res = await fetch(url, { headers, signal: controller.signal });
    clearTimeout(timeout);
    if (res.ok) {
      const data = (await res.json()) as { sha: string; content: string };
      sha = data.sha;
      try {
        existingContent = decodeURIComponent(escape(atob(data.content.replace(/\n/g, ''))));
      } catch {
        // Decoding failed — treat as changed
      }
    }
  } catch {
    // File doesn't exist yet or request failed
  }

  // Skip push if content is unchanged
  if (existingContent !== undefined && existingContent === content) {
    return { updated: false };
  }

  // Create or update file
  const body: Record<string, string> = {
    message: `Update ${path}`,
    content: btoa(unescape(encodeURIComponent(content))),
  };
  if (sha) body.sha = sha;

  const putController = new AbortController();
  const putTimeout = setTimeout(() => putController.abort(), 30000);
  const res = await fetch(url, {
    method: 'PUT',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
    signal: putController.signal,
  });
  clearTimeout(putTimeout);

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`${res.status} ${text.slice(0, 200)}`);
  }

  return { updated: true };
}
